<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.475">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Coastal Consolidation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="dashboard_region_doc_files/libs/clipboard/clipboard.min.js"></script>
<script src="dashboard_region_doc_files/libs/quarto-html/quarto.js"></script>
<script src="dashboard_region_doc_files/libs/quarto-html/popper.min.js"></script>
<script src="dashboard_region_doc_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="dashboard_region_doc_files/libs/quarto-html/anchor.min.js"></script>
<link href="dashboard_region_doc_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="dashboard_region_doc_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="dashboard_region_doc_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="dashboard_region_doc_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="dashboard_region_doc_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Coastal Consolidation</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>The inherent management of most domestic fisheries at a regional scale warrants a need to provide geographic resolution to federal fisheries data. Furthermore, the wide-ranging distribution of highly migratory species (HMS) and their international management suggests the geographic resolution should be at a coastal scale. As stated previously, the FOSS reports federal fisheries data at a city-level for exports and imports via ports of entry and state-level for commercially landed catch. The processed products database also aggregates data at the city-level via the address of the processing plant. Aggregating these data at a coastal level was straightforward. States and territories that border an ocean or gulf were given appropriate coast designations, and those that are landlocked were given no coast designation. Florida, however, straddles two coasts (Atlantic and Gulf) and was thus split in two parts: East-FL and West-FL. We identified cities that belonged to East-FL or West-FL with the aid of Google Gemini, an AI tool. We organized 196 Florida cities found in the processed products and trade data into a .csv file and provided the file to Gemini with the following prompt:</p>
<p><em>“Hello, I have a task for you. I am providing a csv file of city names in the state of Florida, under the column name ‘PLANT_CITY’. Please find whether each city falls nearer to the Gulf coast or the Atlantic Coast of the state of Florida. In a new column named ‘PLANT_COAST’, please list the coast (either ‘ATLANTIC’ or ‘GULF’) nearest to the associated city. If a city is farther inland, please assign the coast nearest to that city. Thanks!”</em></p>
<p>Gemini initially responded to this prompt cooperatively and outputted a dataset following the request. The tool described its methodology as determining the longitude of each city and classifying it as either greater than -81.5 degrees (closer to the Atlantic coast) or less than -81.5 degrees (closer to the Gulf coast). The tool also professed that it could not obtain longitude data for over 80 cities and thus classified their coasts as ‘UNKNOWN’. We sought to investigate the tool’s consistency in performing this task by ingesting the identical prompt used initially as well as the same .csv of florida cities. Strangely, the tool was not able to execute the task upon two consecutive requests made in separate web sessions, and instead issued the following response:</p>
<p><em>“I am sorry, but I am unable to perform this task. I lack the ability to access geographical data and perform the necessary calculations to determine the distance of each city to a specific coast. I cannot access external geographical databases or APIs to find the coordinates of the cities or the coastlines. If you can provide a dataset with the latitude and longitude for each city, I may be able to help.”</em></p>
<p>This response is indeed strange because the tool claims to be unable to find city coordinates, yet prior Gemini outlined its methodology which involved identifying city longitudes and comparing these against the longitude that splits Florida. Regardless of this inconsistency, we validated Gemini’s output by randomly sampling its ‘Atlantic’ coast classifications and ‘Gulf’ coast classifications. We evaluated ten of Gemini’s classifications for each coast and found no incorrect classifications, or 100% accuracy. For cities whose coasts were classified by Gemini as ‘Unknown’, we qualitatively evaluated their proximity to either coast using Google Maps and assigned the appropriate coast. This effort only applies to processed product and trade data as commercial landings data do not provide a city-level resolution; therefore, we classified commercial landings from the state of Florida to the Atlantic region.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>